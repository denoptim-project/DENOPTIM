/*
 *   DENOPTIM
 *   Copyright (C) 2019 Marco Foscato <marco.foscato@uib.no>
 * 
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU Affero General Public License as published
 *   by the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Affero General Public License for more details.
 *
 *   You should have received a copy of the GNU Affero General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package denoptim.fitness;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

import denoptim.exception.DENOPTIMException;
import denoptim.files.FileUtils;
import denoptim.programs.RunTimeParameters;

/**
 * Settings defining the calculation of fitness.
 * 
 * @author Marco Foscato
 */

public class FitnessParameters extends RunTimeParameters
{
    /**
     * Flag indication we want to use external fitness provider
     */
    private boolean useExternalFitness = true;

    /**
     * Pathname of an external fitness provider executable
     */
    private String externalExe = "";

    /**
     * Interpreter for the external fitness provider
     */
    private String interpreterExternalExe = "bash";

    /**
     * Formulation of the internally provided fitness
     */
    private String fitnessExpression = "";
    
    /**
     * List of custom variable definitions read from input. 
     * These lines are the definition of atom/bond specific 
     * descriptors, and custom parametrised descriptors.
     */
	private List<String> customVarDescExpressions = 
			new ArrayList<String>();
    
    /**
     * The list of descriptors needed to calculate the variables that are
     * used to calculate the fitness with the internal fitness provider.
     */
    private List<DescriptorForFitness> descriptors = 
            new ArrayList<DescriptorForFitness>();
    
    /**
     * Flag controlling production of png graphics for each candidate
     */
    private boolean makePictures = false;
    
    /**
     * Flag requesting the generation of a 3d-tree model instead of a plain
     * collection of 3d building blocks. In the latter, the coordinated of each
     * fragment are not changed when building the molecular representation that
     * is sent to the fitness provider. Setting this to <code>true</code> asks
     * for roto-translation of each fragment, but does not perform any 
     * energy-driven refinement of the geometry.
     */
    private boolean make3DTrees = true;
    
    /**
     * Flag requesting to test for uniqueness of a candidate based on the 
     * unique identifier (UID) generated by conversion of the graph into
     * a molecular entity. 
     */
    private boolean checkPreFitnessUID = true;
    
    /**
     * Flag recording that we have explicitly expressed the choice of 
     * checkPreFitnessUID.
     */
    private boolean checkPreFitnessUIDFromInput = false;
    
    /**
     * Flag requesting to write a file that collects all info on an evaluated
     * candidate, i.e., the "FIT" file, even in case of internal fitness. 
     * When this is <code>true</code>, we write one file for each evaluated 
     * candidate. Note that in case of external fitness provider this file is
     * created by the external fitness provider and this flag has no effect.
     */
    private boolean writeCandidatesOnDisk = true;
    
    
//------------------------------------------------------------------------------

    /**
     * Constructor
     */
    public FitnessParameters()
    {
        super(ParametersType.FIT_PARAMS);
    }

//------------------------------------------------------------------------------

    /**
     * @return <code>true</code> if we are asked to execute an external fitness 
     * provider.
     */
    public boolean useExternalFitness()
    {
        return useExternalFitness;
    }
    
//------------------------------------------------------------------------------

    /**
     * @return <code>true</code> if generation of the candidate's picture is 
     * required.
     */
    public boolean makePictures()
    {
        return makePictures;
    }
    
//------------------------------------------------------------------------------
    
    /**
     * @return <code>true</code> if we are asked to make a tree-like 3d 
     * molecular model prior fitness evaluation. The model is built by aligning
     * 3d-building blocks to the attachment point vectors, so there is no 
     * energy refinement.
     */
    public boolean make3dTree()
    {
    	return make3DTrees;
    }

//------------------------------------------------------------------------------
    
    /**
     * @return <code>true</code> if we want to check the unique identifier (UID)
     * of candidates prior to submitting them to the fitness provider.
     */
    public boolean checkPreFitnessUID()
    {
        return checkPreFitnessUID;
    }
    
//------------------------------------------------------------------------------

    /**
     * Gets the pathname of the external executable file.
     * @return the pathname to the external fitness provider.
     */
    public String getExternalFitnessProvider()
    {
        return externalExe;
    }
    
//------------------------------------------------------------------------------

    /**
     * Gets the interpreter used to run the external fitness provider.
     * @return the interpreter name.
     */
    public String getExternalFitnessProviderInterpreter()
    {
        return interpreterExternalExe;
    }
    
//------------------------------------------------------------------------------
    
    /**
     * @return the expression used to calculate the fitness with the internal
     * fitness provider
     */
    public String getFitnessExpression()
    {
    	return fitnessExpression;
    }
    
//------------------------------------------------------------------------------
    
    /**
     * @return list of descriptors needed to calculate the fitness
     */
    public List<DescriptorForFitness> getDescriptors()
    {
    	return descriptors;
    }

//------------------------------------------------------------------------------

    public void interpretKeyword(String key, String value) throws DENOPTIMException
    {
        String msg = "";
        switch (key.toUpperCase())
        {
            case "SOURCE=":
            	externalExe = value;
                break;
                
            case "INTERPRETER=":
            	interpreterExternalExe = value;
                break;
                
            case "EQUATION=":
            	fitnessExpression = value;
            	useExternalFitness = false;
                break;
                
            case "DESCRIPTORSPECS=":
            	customVarDescExpressions.add(value);
            	break;
                
            case "MAKEPICTURES":
    	        makePictures = true;
    	        break;
    	        
            case "NO3DTREEMODEL":
            	make3DTrees = false;
            	break;
            	
            case "DONTWRITECANDIDATESONDISK":
                writeCandidatesOnDisk = false;
                break;
            	
            case "CHECKUIDBEFOREFITNESS=":
                checkPreFitnessUID = readYesNoTrueFalse(value);
                checkPreFitnessUIDFromInput = true;
                break;
    
            default:
                 msg = "Keyword " + key + " is not a known fitness-related "
                 		+ "keyword. Check input files.";
                throw new DENOPTIMException(msg);
        }
    }

//------------------------------------------------------------------------------

    public void checkParameters() throws DENOPTIMException
    {
        String msg = "";
        if ((externalExe.length() != 0) 
        	&& (!FileUtils.checkExists(externalExe)))
        {
            msg = "Cannot find the fitness provider: " + externalExe;
            throw new DENOPTIMException(msg);
        }
        checkOtherParameters();
    }

//------------------------------------------------------------------------------

    public void processParameters() throws DENOPTIMException
    {
    	if (!fitnessExpression.equals(""))
    	{
	        FitnessExpressionParser fep = new FitnessExpressionParser();
    	    fep.parse(fitnessExpression, customVarDescExpressions);
    	    descriptors = fep.getDescriptors();
    	}
    	if (!checkPreFitnessUIDFromInput && useExternalFitness)
    	    checkPreFitnessUID = false;
    	    
    	processOtherParameters();
    }
    
//------------------------------------------------------------------------------

    /**
     * Returns the list of parameters in a string with newline characters as
     * delimiters.
     * @return the list of parameters in a string with newline characters as
     * delimiters.
     */
    public String getPrintedList()
    {
        StringBuilder sb = new StringBuilder(1024);
        sb.append(" " + paramTypeName() + " ").append(NL);
        for (Field f : this.getClass().getDeclaredFields()) 
        {
            try
            {
                sb.append(f.getName()).append(" = ").append(
                            f.get(this)).append(NL);
            }
            catch (Throwable t)
            {
                sb.append("ERROR! Unable to print " + paramTypeName() 
                        + " parameters. Cause: " + t);
                break;
            }
        }
        for (RunTimeParameters otherCollector : otherParameters.values())
        {
            sb.append(otherCollector.getPrintedList());
        }
        return sb.toString();
    }
    
//------------------------------------------------------------------------------

    /**
     * @return <code>true</code> if we are asked to write on disk every 
     * candidate that has been evaluated.
     */
    public boolean writeCandidatesOnDisk()
    {
        return writeCandidatesOnDisk;
    }
    
//------------------------------------------------------------------------------

}
