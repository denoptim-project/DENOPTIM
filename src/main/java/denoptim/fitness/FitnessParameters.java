/*
 *   DENOPTIM
 *   Copyright (C) 2019 Marco Foscato <marco.foscato@uib.no>
 * 
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU Affero General Public License as published
 *   by the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Affero General Public License for more details.
 *
 *   You should have received a copy of the GNU Affero General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package denoptim.fitness;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import jakarta.el.ELContext;
import jakarta.el.ELResolver;
import jakarta.el.ExpressionFactory;
import jakarta.el.FunctionMapper;
import jakarta.el.ValueExpression;
import jakarta.el.VariableMapper;

import org.openscience.cdk.exception.CDKException;
import org.openscience.cdk.fingerprint.IBitFingerprint;
import org.openscience.cdk.fingerprint.IFingerprinter;
import org.openscience.cdk.fingerprint.ShortestPathFingerprinter;
import org.openscience.cdk.fingerprint.SubstructureFingerprinter;
import org.openscience.cdk.interfaces.IAtomContainer;
import org.openscience.cdk.qsar.IDescriptor;
import org.openscience.cdk.tools.manipulator.AtomContainerManipulator;

import denoptim.exception.DENOPTIMException;
import denoptim.files.FileUtils;
import denoptim.fitness.descriptors.TanimotoMolSimilarity;
import denoptim.fitness.descriptors.TanimotoMolSimilarityBySubstructure;
import denoptim.io.DenoptimIO;
import denoptim.logging.DENOPTIMLogger;


/**
 * Parameters defining the fitness providers.
 * 
 * @author Marco Foscato
 */

public class FitnessParameters
{
    /**
     * Flag indicating that at least one FS-parameter has been defined
     */
    private static boolean fitParamsInUse = false;
    
    /**
     * Flag indication we want to use external fitness provider
     */
    private static boolean useExternalFitness = true;

    /**
     * Pathname of an external fitness provider executable
     */
    private static String externalExe = "";

    /**
     * Interpreter for the external fitness provider
     */
    private static String interpreterExternalExe = "bash";

    /**
     * Formulation of the internally provided fitness
     */
    private static String fitnessExpression = "";
    
    /**
     * List of custom variable definitions read from input. 
     * These lines are the definition of atom/bond specific 
     * descriptors, and custom parametrised descriptors.
     */
	private static List<String> customVarDescExpressions = 
			new ArrayList<String>();
    
    /**
     * List of variables used in the calculation of the fitness. 
     * For instance, atom/bond specific descriptors, and custom parameterized 
     * descriptors.
     */
    private static List<Variable> variables = new ArrayList<Variable>();
    
    /**
     * The list of descriptors needed to calculate the variables that are
     * used to calculate the fitness with the internal fitness provider.
     */
    private static List<DescriptorForFitness> descriptors = 
            new ArrayList<DescriptorForFitness>();
    
    /**
     * Flag controlling production of png graphics for each candidate
     */
    private static boolean makePictures = false;
    
    /**
     * Flag requesting the generation of a 3d-tree model instead of a plain
     * collection of 3d building blocks. In the latter, the coordinated of each
     * fragment are not changed when building the molecular representation that
     * is sent to the fitness provider. Setting this to <code>true</code> asks
     * for roto-translation of each fragment, but does not perform any 
     * energy-driven refinement of the geometry.
     */
    private static boolean make3DTrees = true;
    
    /**
     * Flag requesting to test for uniqueness of a candidate based on the 
     * unique identifier (UID) generated by conversion of the graph into
     * a molecular entity. See 
     */
    private static boolean checkPreFitnessUID = true;

    
    //TODO-V3 should all this stuff be static? Check!
    
//------------------------------------------------------------------------------


    public static void resetParameters()
    {
    	fitParamsInUse = false;
    	useExternalFitness = true;
    	externalExe = "";
    	interpreterExternalExe = "bash";
    	fitnessExpression = "";
    	customVarDescExpressions = new ArrayList<String>();
    	descriptors = new ArrayList<DescriptorForFitness>();
    	variables = new ArrayList<Variable>();
    	makePictures = false;
    	make3DTrees = true;
    	checkPreFitnessUID = !useExternalFitness;
    }
    
//------------------------------------------------------------------------------

    public static boolean fitParamsInUse()
    {
        return fitParamsInUse;
    }

//------------------------------------------------------------------------------

    /**
     * @return <code>true</code> if we are asked to execute an external fitness 
     * provider.
     */
    public static boolean useExternalFitness()
    {
        return useExternalFitness;
    }
    
//------------------------------------------------------------------------------

    /**
     * @return <code>true</code> if generation of the candidate's picture is 
     * required.
     */
    public static boolean makePictures()
    {
        return makePictures;
    }
    
//------------------------------------------------------------------------------
    
    /**
     * @return <code>true</code> if we are asked to make a tree-like 3d 
     * molecular model prior fitness evaluation. The model is built by aligning
     * 3d-building blocks to the attachment point vectors, so there is no 
     * energy refinement.
     */
    public static boolean make3dTree()
    {
    	return make3DTrees;
    }

//------------------------------------------------------------------------------
    
    /**
     * @return <code>true</code> if we want to check the unique identifier (UID)
     * of candidates prior to submitting them to the fitness provider.
     */
    public static boolean checkPreFitnessUID()
    {
        return checkPreFitnessUID;
    }
    
//------------------------------------------------------------------------------

    /**
     * Gets the pathname of the external executable file.
     * @return the pathname to the external fitness provider.
     */
    public static String getExternalFitnessProvider()
    {
        return externalExe;
    }
    
//------------------------------------------------------------------------------

    /**
     * Gets the interpreter used to run the external fitness provider.
     * @return the interpreter name.
     */
    public static String getExternalFitnessProviderInterpreter()
    {
        return interpreterExternalExe;
    }
    
//------------------------------------------------------------------------------
    
    /**
     * @return the expression used to calculate the fitness with the internal
     * fitness provider
     */
    public static String getFitnessExpression()
    {
    	return fitnessExpression;
    }
    
//------------------------------------------------------------------------------
    
    /**
     * @return list of descriptors needed to calculate the fitness
     */
    public static List<DescriptorForFitness> getDescriptors()
    {
    	return descriptors;
    }

//------------------------------------------------------------------------------
    
    public static void interpretKeyword(String line) throws DENOPTIMException
    {
        String key = line.trim();
        String value = "";
        if (line.contains("="))
        {
            key = line.substring(0,line.indexOf("=") + 1).trim();
            value = line.substring(line.indexOf("=") + 1).trim();
        }
        try
        {
            interpretKeyword(key,value);
        }
        catch (DENOPTIMException e)
        {
            throw new DENOPTIMException(e.getMessage()+" Check line "+line);
        }
    }

//------------------------------------------------------------------------------

    public static void interpretKeyword(String key, String value)
                                                      throws DENOPTIMException
    {
        String msg = "";
        switch (key.toUpperCase())
        {
        case "FP-SOURCE=":
        	externalExe = value;
        	fitParamsInUse = true;
            break;
            
        case "FP-INTERPRETER=":
        	interpreterExternalExe = value;
        	fitParamsInUse = true;
            break;
            
        case "FP-EQUATION=":
        	fitnessExpression = value;
        	fitParamsInUse = true;
        	useExternalFitness = false;
            break;
            
        case "FP-DESCRIPTORSPECS=":
        	customVarDescExpressions.add(value);
        	break;
            
        case "FP-MAKEPICTURES":
        	fitParamsInUse = true;
	        makePictures = true;
	        break;
	        
        case "FP-NO3DTREEMODEL":
        	make3DTrees = false;
        	break;
        	
        case "FP-CHECKUIDBEFOREFITNESS":
            checkPreFitnessUID = true; 
            break;

        default:
             msg = "Keyword " + key + " is not a known fitness-related "
             		+ "keyword. Check input files.";
            throw new DENOPTIMException(msg);
        }
    }

//------------------------------------------------------------------------------

    public static void checkParameters() throws DENOPTIMException
    {
        String msg = "";
        if (!fitParamsInUse)
        {
            return;
        }

        if ((externalExe.length() != 0) 
        	&& (!FileUtils.checkExists(externalExe)))
        {
            msg = "Cannot find the fitness provider: " + externalExe;
            throw new DENOPTIMException(msg);
        }

        if (interpreterExternalExe.length() != 0)
        {
        	switch (interpreterExternalExe.toUpperCase())
        	{
	        	case "BASH":
	        		break;
	        		
	        	case "PYTHON":
	        		break;
/*
//TODO: add 
	        	case "JAVA":
	        		break;
*/
	        	default:
	        		msg = "Interpreter '" + interpreterExternalExe 
	        										 + "' not available.";
	                throw new DENOPTIMException(msg);
        	}
        }
    }

//------------------------------------------------------------------------------

    public static void processParameters() throws DENOPTIMException
    {
    	if (!fitnessExpression.equals(""))
    	{
	        FitnessExpressionParser fep = new FitnessExpressionParser();
    	    fep.parse(fitnessExpression, customVarDescExpressions);
    	    variables = fep.getVariables();
    	    descriptors = fep.getDescriptors();
    	}
    }

//------------------------------------------------------------------------------

    public static void printParameters()
    {
		if (!fitParamsInUse)
		{
		    return;
		}
        String eol = System.getProperty("line.separator");
        StringBuilder sb = new StringBuilder(1024);
        sb.append(" FitnessParameters ").append(eol);
        for (Field f : FitnessParameters.class.getDeclaredFields()) 
        {
        	try
            {
                sb.append(f.getName()).append(" = ").append(
                            f.get(FitnessParameters.class)).append(eol);
            }
            catch (Throwable t)
            {
            	t.printStackTrace();
                sb.append("ERROR! Unable to print FitnessParameters.");
                break;
            }
        }
        DENOPTIMLogger.appLogger.info(sb.toString());
        sb.setLength(0);
    }

//------------------------------------------------------------------------------

}
