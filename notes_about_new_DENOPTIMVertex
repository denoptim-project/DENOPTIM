* construct vertex in type-agnostic way: we need a general constructor that can
  take molID and fragType, or some other kind of identified for the building 
  blocks stored in the library.

* MolId and fragment-type are used to point to a specific fragment in the 
  library without pointing to a specific vertex (so, cannot use vertex ID). 
  Similarly, an index is used to point to an attachment point.
** PathSubGraph (need to collect all possible chain IDs in a
   llPossibleChainIDs, and the chain ID needs to be independent from the actual 
   vertex ID, while it should point to a specific fragment in the library.)
** DENOPTIMGraphEdit has a similar need: point to an undefined vertex that 
   contains a specific fragment from the fragment space.
** GraphUtils.findVertices too has the need to detect vertices that CAN be
   fragments and CAN have a specific molID+fragTyp pair
** FragsCombinationIterator
** see IdFragmentAndAP 
** also utils like EAUtils.selectClassBasedFragment are heavily driven by the 
   ID-based referencing to vertices in the fragment library and to their APs

* About identifiers in general: can be avoided as long as we work with 
  references? The moment we export/store/import graphs and vertices, we need
  a txt-based representation that either 
  * points to an existing library (as originally done in denoptim), or 
  * embeds ALL the data needed to define the building blocks.
  The latter is a problem, because upon importing graphs, we need to identify
  if the building blocks of the imported graph are already part of a loaded 
  fragment space, or are new fragments (probably to be added to the loaded 
  fragment space.
  IDs are also used to keep track of where we are when iterating over lists
  of combination (i.e., checkpoint-file of FSE)
  
* Decisions on identifiers are tightly bound to re-design of string 
  representation of a Graph. A new txt-based representation could solve the 
  problem of not knowing how many APs are effectively available on a vertex
  that belongs to a graph when reading a graph on its own (e.g., via GUI).
  This, unless we have access to the actual library of fragments used to 
  build that graph. 

* check comparison vertices.

* when converting graph to molecule 3D, get 3D molecular representation of 
  vertex, if any, or skip if none is available. 

* should not allow setVertexId

* the level of a vertex "a.k.a. recursionLevel) should not be a property of a
  vertex alone, but should exist in the graph.